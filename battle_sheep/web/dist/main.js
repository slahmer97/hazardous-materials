/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ls");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../../node_modules/maquette/dist/maquette.umd.js":
/*!*************************************************************!*\
  !*** /home/mich/node_modules/maquette/dist/maquette.umd.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports) :\n    undefined;\n}(this, (function (exports) { 'use strict';\n\n    /* tslint:disable no-http-string */\r\n    var NAMESPACE_W3 = 'http://www.w3.org/';\r\n    /* tslint:enable no-http-string */\r\n    var NAMESPACE_SVG = NAMESPACE_W3 + \"2000/svg\";\r\n    var NAMESPACE_XLINK = NAMESPACE_W3 + \"1999/xlink\";\r\n    var emptyArray = [];\r\n    var extend = function (base, overrides) {\r\n        var result = {};\r\n        Object.keys(base).forEach(function (key) {\r\n            result[key] = base[key];\r\n        });\r\n        if (overrides) {\r\n            Object.keys(overrides).forEach(function (key) {\r\n                result[key] = overrides[key];\r\n            });\r\n        }\r\n        return result;\r\n    };\r\n    var same = function (vnode1, vnode2) {\r\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\r\n            return false;\r\n        }\r\n        if (vnode1.properties && vnode2.properties) {\r\n            if (vnode1.properties.key !== vnode2.properties.key) {\r\n                return false;\r\n            }\r\n            return vnode1.properties.bind === vnode2.properties.bind;\r\n        }\r\n        return !vnode1.properties && !vnode2.properties;\r\n    };\r\n    var checkStyleValue = function (styleValue) {\r\n        if (typeof styleValue !== 'string') {\r\n            throw new Error('Style values must be strings');\r\n        }\r\n    };\r\n    var findIndexOfChild = function (children, sameAs, start) {\r\n        if (sameAs.vnodeSelector !== '') {\r\n            // Never scan for text-nodes\r\n            for (var i = start; i < children.length; i++) {\r\n                if (same(children[i], sameAs)) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\r\n        var childNode = childNodes[indexToCheck];\r\n        if (childNode.vnodeSelector === '') {\r\n            return; // Text nodes need not be distinguishable\r\n        }\r\n        var properties = childNode.properties;\r\n        var key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;\r\n        if (!key) { // A key is just assumed to be unique\r\n            for (var i = 0; i < childNodes.length; i++) {\r\n                if (i !== indexToCheck) {\r\n                    var node = childNodes[i];\r\n                    if (same(node, childNode)) {\r\n                        throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" + (operation === 'added' ? operation : 'removed') + \", but there is now more than one. You must add unique key properties to make them distinguishable.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var nodeAdded = function (vNode) {\r\n        if (vNode.properties) {\r\n            var enterAnimation = vNode.properties.enterAnimation;\r\n            if (enterAnimation) {\r\n                enterAnimation(vNode.domNode, vNode.properties);\r\n            }\r\n        }\r\n    };\r\n    var removedNodes = [];\r\n    var requestedIdleCallback = false;\r\n    var visitRemovedNode = function (node) {\r\n        (node.children || []).forEach(visitRemovedNode);\r\n        if (node.properties && node.properties.afterRemoved) {\r\n            node.properties.afterRemoved.apply(node.properties.bind || node.properties, [node.domNode]);\r\n        }\r\n    };\r\n    var processPendingNodeRemovals = function () {\r\n        requestedIdleCallback = false;\r\n        removedNodes.forEach(visitRemovedNode);\r\n        removedNodes.length = 0;\r\n    };\r\n    var scheduleNodeRemoval = function (vNode) {\r\n        removedNodes.push(vNode);\r\n        if (!requestedIdleCallback) {\r\n            requestedIdleCallback = true;\r\n            if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\r\n                window.requestIdleCallback(processPendingNodeRemovals, { timeout: 16 });\r\n            }\r\n            else {\r\n                setTimeout(processPendingNodeRemovals, 16);\r\n            }\r\n        }\r\n    };\r\n    var nodeToRemove = function (vNode) {\r\n        var domNode = vNode.domNode;\r\n        if (vNode.properties) {\r\n            var exitAnimation = vNode.properties.exitAnimation;\r\n            if (exitAnimation) {\r\n                domNode.style.pointerEvents = 'none';\r\n                var removeDomNode = function () {\r\n                    if (domNode.parentNode) {\r\n                        domNode.parentNode.removeChild(domNode);\r\n                        scheduleNodeRemoval(vNode);\r\n                    }\r\n                };\r\n                exitAnimation(domNode, removeDomNode, vNode.properties);\r\n                return;\r\n            }\r\n        }\r\n        if (domNode.parentNode) {\r\n            domNode.parentNode.removeChild(domNode);\r\n            scheduleNodeRemoval(vNode);\r\n        }\r\n    };\r\n    var setProperties = function (domNode, properties, projectionOptions) {\r\n        if (!properties) {\r\n            return;\r\n        }\r\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n        var propNames = Object.keys(properties);\r\n        var propCount = propNames.length;\r\n        var _loop_1 = function (i) {\r\n            var propName = propNames[i];\r\n            var propValue = properties[propName];\r\n            if (propName === 'className') {\r\n                throw new Error('Property \"className\" is not supported, use \"class\".');\r\n            }\r\n            else if (propName === 'class') {\r\n                toggleClasses(domNode, propValue, true);\r\n            }\r\n            else if (propName === 'classes') {\r\n                // object with string keys and boolean values\r\n                var classNames = Object.keys(propValue);\r\n                var classNameCount = classNames.length;\r\n                for (var j = 0; j < classNameCount; j++) {\r\n                    var className = classNames[j];\r\n                    if (propValue[className]) {\r\n                        domNode.classList.add(className);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName === 'styles') {\r\n                // object with string keys and string (!) values\r\n                var styleNames = Object.keys(propValue);\r\n                var styleCount = styleNames.length;\r\n                for (var j = 0; j < styleCount; j++) {\r\n                    var styleName = styleNames[j];\r\n                    var styleValue = propValue[styleName];\r\n                    if (styleValue) {\r\n                        checkStyleValue(styleValue);\r\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName !== 'key' && propValue !== null && propValue !== undefined) {\r\n                var type = typeof propValue;\r\n                if (type === 'function') {\r\n                    if (propName.lastIndexOf('on', 0) === 0) { // lastIndexOf(,0)===0 -> startsWith\r\n                        if (eventHandlerInterceptor) {\r\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\r\n                        }\r\n                        if (propName === 'oninput') {\r\n                            /* tslint:disable no-this-keyword no-invalid-this only-arrow-functions no-void-expression */\r\n                            (function () {\r\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\r\n                                var oldPropValue = propValue;\r\n                                propValue = function (evt) {\r\n                                    oldPropValue.apply(this, [evt]);\r\n                                    evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well\r\n                                };\r\n                            }());\r\n                            /* tslint:enable */\r\n                        }\r\n                        domNode[propName] = propValue;\r\n                    }\r\n                }\r\n                else if (projectionOptions.namespace === NAMESPACE_SVG) {\r\n                    if (propName === 'href') {\r\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\r\n                    }\r\n                    else {\r\n                        // all SVG attributes are read-only in DOM, so...\r\n                        domNode.setAttribute(propName, propValue);\r\n                    }\r\n                }\r\n                else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\r\n                    domNode.setAttribute(propName, propValue);\r\n                }\r\n                else {\r\n                    domNode[propName] = propValue;\r\n                }\r\n            }\r\n        };\r\n        for (var i = 0; i < propCount; i++) {\r\n            _loop_1(i);\r\n        }\r\n    };\r\n    var addChildren = function (domNode, children, projectionOptions) {\r\n        if (!children) {\r\n            return;\r\n        }\r\n        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n            var child = children_1[_i];\r\n            createDom(child, domNode, undefined, projectionOptions);\r\n        }\r\n    };\r\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\r\n        addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\r\n        if (vnode.text) {\r\n            domNode.textContent = vnode.text;\r\n        }\r\n        setProperties(domNode, vnode.properties, projectionOptions);\r\n        if (vnode.properties && vnode.properties.afterCreate) {\r\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\r\n        }\r\n    };\r\n    var createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\r\n        var domNode;\r\n        var start = 0;\r\n        var vnodeSelector = vnode.vnodeSelector;\r\n        var doc = parentNode.ownerDocument;\r\n        if (vnodeSelector === '') {\r\n            domNode = vnode.domNode = doc.createTextNode(vnode.text);\r\n            if (insertBefore !== undefined) {\r\n                parentNode.insertBefore(domNode, insertBefore);\r\n            }\r\n            else {\r\n                parentNode.appendChild(domNode);\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i <= vnodeSelector.length; ++i) {\r\n                var c = vnodeSelector.charAt(i);\r\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\r\n                    var type = vnodeSelector.charAt(start - 1);\r\n                    var found = vnodeSelector.slice(start, i);\r\n                    if (type === '.') {\r\n                        domNode.classList.add(found);\r\n                    }\r\n                    else if (type === '#') {\r\n                        domNode.id = found;\r\n                    }\r\n                    else {\r\n                        if (found === 'svg') {\r\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n                        }\r\n                        if (projectionOptions.namespace !== undefined) {\r\n                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);\r\n                        }\r\n                        else {\r\n                            domNode = vnode.domNode = (vnode.domNode || doc.createElement(found));\r\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\r\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\r\n                                domNode.setAttribute('type', vnode.properties.type);\r\n                            }\r\n                        }\r\n                        if (insertBefore !== undefined) {\r\n                            parentNode.insertBefore(domNode, insertBefore);\r\n                        }\r\n                        else if (domNode.parentNode !== parentNode) {\r\n                            parentNode.appendChild(domNode);\r\n                        }\r\n                    }\r\n                    start = i + 1;\r\n                }\r\n            }\r\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\r\n        }\r\n    };\r\n    var updateDom;\r\n    /**\r\n     * Adds or removes classes from an Element\r\n     * @param domNode the element\r\n     * @param classes a string separated list of classes\r\n     * @param on true means add classes, false means remove\r\n     */\r\n    var toggleClasses = function (domNode, classes, on) {\r\n        if (!classes) {\r\n            return;\r\n        }\r\n        classes.split(' ').forEach(function (c) { return domNode.classList.toggle(c, on); });\r\n    };\r\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\r\n        if (!properties) {\r\n            return;\r\n        }\r\n        var propertiesUpdated = false;\r\n        var propNames = Object.keys(properties);\r\n        var propCount = propNames.length;\r\n        for (var i = 0; i < propCount; i++) {\r\n            var propName = propNames[i];\r\n            // assuming that properties will be nullified instead of missing is by design\r\n            var propValue = properties[propName];\r\n            var previousValue = previousProperties[propName];\r\n            if (propName === 'class') {\r\n                if (previousValue !== propValue) {\r\n                    toggleClasses(domNode, previousValue, false);\r\n                    toggleClasses(domNode, propValue, true);\r\n                }\r\n            }\r\n            else if (propName === 'classes') {\r\n                var classList = domNode.classList;\r\n                var classNames = Object.keys(propValue);\r\n                var classNameCount = classNames.length;\r\n                for (var j = 0; j < classNameCount; j++) {\r\n                    var className = classNames[j];\r\n                    var on = !!propValue[className];\r\n                    var previousOn = !!previousValue[className];\r\n                    if (on === previousOn) {\r\n                        continue;\r\n                    }\r\n                    propertiesUpdated = true;\r\n                    if (on) {\r\n                        classList.add(className);\r\n                    }\r\n                    else {\r\n                        classList.remove(className);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName === 'styles') {\r\n                var styleNames = Object.keys(propValue);\r\n                var styleCount = styleNames.length;\r\n                for (var j = 0; j < styleCount; j++) {\r\n                    var styleName = styleNames[j];\r\n                    var newStyleValue = propValue[styleName];\r\n                    var oldStyleValue = previousValue[styleName];\r\n                    if (newStyleValue === oldStyleValue) {\r\n                        continue;\r\n                    }\r\n                    propertiesUpdated = true;\r\n                    if (newStyleValue) {\r\n                        checkStyleValue(newStyleValue);\r\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\r\n                    }\r\n                    else {\r\n                        projectionOptions.styleApplyer(domNode, styleName, '');\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (!propValue && typeof previousValue === 'string') {\r\n                    propValue = '';\r\n                }\r\n                if (propName === 'value') { // value can be manipulated by the user directly and using event.preventDefault() is not an option\r\n                    var domValue = domNode[propName];\r\n                    if (domValue !== propValue // The 'value' in the DOM tree !== newValue\r\n                        && (domNode['oninput-value']\r\n                            ? domValue === domNode['oninput-value'] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput\r\n                            : propValue !== previousValue // Only update the value if the vdom changed\r\n                        )) {\r\n                        // The edge cases are described in the tests\r\n                        domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\r\n                        domNode['oninput-value'] = undefined;\r\n                    } // else do not update the domNode, otherwise the cursor position would be changed\r\n                    if (propValue !== previousValue) {\r\n                        propertiesUpdated = true;\r\n                    }\r\n                }\r\n                else if (propValue !== previousValue) {\r\n                    var type = typeof propValue;\r\n                    if (type !== 'function' || !projectionOptions.eventHandlerInterceptor) { // Function updates are expected to be handled by the EventHandlerInterceptor\r\n                        if (projectionOptions.namespace === NAMESPACE_SVG) {\r\n                            if (propName === 'href') {\r\n                                domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\r\n                            }\r\n                            else {\r\n                                // all SVG attributes are read-only in DOM, so...\r\n                                domNode.setAttribute(propName, propValue);\r\n                            }\r\n                        }\r\n                        else if (type === 'string' && propName !== 'innerHTML') {\r\n                            if (propName === 'role' && propValue === '') {\r\n                                domNode.removeAttribute(propName);\r\n                            }\r\n                            else {\r\n                                domNode.setAttribute(propName, propValue);\r\n                            }\r\n                        }\r\n                        else if (domNode[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\r\n                            domNode[propName] = propValue;\r\n                        }\r\n                        propertiesUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return propertiesUpdated;\r\n    };\r\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\r\n        if (oldChildren === newChildren) {\r\n            return false;\r\n        }\r\n        oldChildren = oldChildren || emptyArray;\r\n        newChildren = newChildren || emptyArray;\r\n        var oldChildrenLength = oldChildren.length;\r\n        var newChildrenLength = newChildren.length;\r\n        var oldIndex = 0;\r\n        var newIndex = 0;\r\n        var i;\r\n        var textUpdated = false;\r\n        while (newIndex < newChildrenLength) {\r\n            var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\r\n            var newChild = newChildren[newIndex];\r\n            if (oldChild !== undefined && same(oldChild, newChild)) {\r\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\r\n                oldIndex++;\r\n            }\r\n            else {\r\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\r\n                if (findOldIndex >= 0) {\r\n                    // Remove preceding missing children\r\n                    for (i = oldIndex; i < findOldIndex; i++) {\r\n                        nodeToRemove(oldChildren[i]);\r\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n                    }\r\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\r\n                    oldIndex = findOldIndex + 1;\r\n                }\r\n                else {\r\n                    // New child\r\n                    createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\r\n                    nodeAdded(newChild);\r\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\r\n                }\r\n            }\r\n            newIndex++;\r\n        }\r\n        if (oldChildrenLength > oldIndex) {\r\n            // Remove child fragments\r\n            for (i = oldIndex; i < oldChildrenLength; i++) {\r\n                nodeToRemove(oldChildren[i]);\r\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n            }\r\n        }\r\n        return textUpdated;\r\n    };\r\n    updateDom = function (previous, vnode, projectionOptions) {\r\n        var domNode = previous.domNode;\r\n        var textUpdated = false;\r\n        if (previous === vnode) {\r\n            return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\r\n        }\r\n        var updated = false;\r\n        if (vnode.vnodeSelector === '') {\r\n            if (vnode.text !== previous.text) {\r\n                var newTextNode = domNode.ownerDocument.createTextNode(vnode.text);\r\n                domNode.parentNode.replaceChild(newTextNode, domNode);\r\n                vnode.domNode = newTextNode;\r\n                textUpdated = true;\r\n                return textUpdated;\r\n            }\r\n            vnode.domNode = domNode;\r\n        }\r\n        else {\r\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\r\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n            }\r\n            if (previous.text !== vnode.text) {\r\n                updated = true;\r\n                if (vnode.text === undefined) {\r\n                    domNode.removeChild(domNode.firstChild); // the only textnode presumably\r\n                }\r\n                else {\r\n                    domNode.textContent = vnode.text;\r\n                }\r\n            }\r\n            vnode.domNode = domNode;\r\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\r\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\r\n            if (vnode.properties && vnode.properties.afterUpdate) {\r\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\r\n            }\r\n        }\r\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\r\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\r\n        }\r\n        return textUpdated;\r\n    };\r\n    var createProjection = function (vnode, projectionOptions) {\r\n        return {\r\n            getLastRender: function () { return vnode; },\r\n            update: function (updatedVnode) {\r\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\r\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\r\n                }\r\n                var previousVNode = vnode;\r\n                vnode = updatedVnode;\r\n                updateDom(previousVNode, updatedVnode, projectionOptions);\r\n            },\r\n            domNode: vnode.domNode\r\n        };\r\n    };\n\n    var DEFAULT_PROJECTION_OPTIONS = {\r\n        namespace: undefined,\r\n        performanceLogger: function () { return undefined; },\r\n        eventHandlerInterceptor: undefined,\r\n        styleApplyer: function (domNode, styleName, value) {\r\n            // Provides a hook to add vendor prefixes for browsers that still need it.\r\n            domNode.style[styleName] = value;\r\n        }\r\n    };\r\n    var applyDefaultProjectionOptions = function (projectorOptions) {\r\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\r\n    };\r\n    var dom = {\r\n        /**\r\n         * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\r\n         * its [[Projection.domNode|domNode]] property.\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection.\r\n         * @returns The [[Projection]] which also contains the DOM Node that was created.\r\n         */\r\n        create: function (vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Appends a new child node to the DOM which is generated from a [[VNode]].\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param parentNode - The parent node for the new child node.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        append: function (parentNode, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, parentNode, undefined, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Inserts a new DOM node which is generated from a [[VNode]].\r\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n         * @param beforeNode - The node that the DOM Node is inserted before.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\r\n         * NOTE: [[VNode]] objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\r\n         * This means that the virtual DOM and the real DOM will have one overlapping element.\r\n         * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\r\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n         * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\r\n         * may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        merge: function (element, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            vnode.domNode = element;\r\n            initPropertiesAndChildren(element, vnode, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Replaces an existing DOM node with a node generated from a [[VNode]].\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param element - The node for the [[VNode]] to replace.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        replace: function (element, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, element.parentNode, element, projectionOptions);\r\n            element.parentNode.removeChild(element);\r\n            return createProjection(vnode, projectionOptions);\r\n        }\r\n    };\n\n    /* tslint:disable function-name */\r\n    var toTextVNode = function (data) {\r\n        return {\r\n            vnodeSelector: '',\r\n            properties: undefined,\r\n            children: undefined,\r\n            text: data.toString(),\r\n            domNode: null\r\n        };\r\n    };\r\n    var appendChildren = function (parentSelector, insertions, main) {\r\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\r\n            var item = insertions[i];\r\n            if (Array.isArray(item)) {\r\n                appendChildren(parentSelector, item, main);\r\n            }\r\n            else {\r\n                if (item !== null && item !== undefined && item !== false) {\r\n                    if (typeof item === 'string') {\r\n                        item = toTextVNode(item);\r\n                    }\r\n                    main.push(item);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    function h(selector, properties, children) {\r\n        if (Array.isArray(properties)) {\r\n            children = properties;\r\n            properties = undefined;\r\n        }\r\n        else if ((properties && (typeof properties === 'string' || properties.hasOwnProperty('vnodeSelector'))) ||\r\n            (children && (typeof children === 'string' || children.hasOwnProperty('vnodeSelector')))) {\r\n            throw new Error('h called with invalid arguments');\r\n        }\r\n        var text;\r\n        var flattenedChildren;\r\n        // Recognize a common special case where there is only a single text node\r\n        if (children && children.length === 1 && typeof children[0] === 'string') {\r\n            text = children[0];\r\n        }\r\n        else if (children) {\r\n            flattenedChildren = [];\r\n            appendChildren(selector, children, flattenedChildren);\r\n            if (flattenedChildren.length === 0) {\r\n                flattenedChildren = undefined;\r\n            }\r\n        }\r\n        return {\r\n            vnodeSelector: selector,\r\n            properties: properties,\r\n            children: flattenedChildren,\r\n            text: (text === '') ? undefined : text,\r\n            domNode: null\r\n        };\r\n    }\n\n    var createParentNodePath = function (node, rootNode) {\r\n        var parentNodePath = [];\r\n        while (node !== rootNode) {\r\n            parentNodePath.push(node);\r\n            node = node.parentNode;\r\n        }\r\n        return parentNodePath;\r\n    };\r\n    var find;\r\n    if (Array.prototype.find) {\r\n        find = function (items, predicate) { return items.find(predicate); };\r\n    }\r\n    else {\r\n        find = function (items, predicate) { return items.filter(predicate)[0]; };\r\n    }\r\n    var findVNodeByParentNodePath = function (vnode, parentNodePath) {\r\n        var result = vnode;\r\n        parentNodePath.forEach(function (node) {\r\n            result = (result && result.children) ? find(result.children, function (child) { return child.domNode === node; }) : undefined;\r\n        });\r\n        return result;\r\n    };\r\n    var createEventHandlerInterceptor = function (projector, getProjection, performanceLogger) {\r\n        var modifiedEventHandler = function (evt) {\r\n            performanceLogger('domEvent', evt);\r\n            var projection = getProjection();\r\n            var parentNodePath = createParentNodePath(evt.currentTarget, projection.domNode);\r\n            parentNodePath.reverse();\r\n            var matchingVNode = findVNodeByParentNodePath(projection.getLastRender(), parentNodePath);\r\n            projector.scheduleRender();\r\n            var result;\r\n            if (matchingVNode) {\r\n                /* tslint:disable no-invalid-this */\r\n                result = matchingVNode.properties[\"on\" + evt.type].apply(matchingVNode.properties.bind || this, arguments);\r\n                /* tslint:enable no-invalid-this */\r\n            }\r\n            performanceLogger('domEventProcessed', evt);\r\n            return result;\r\n        };\r\n        return function (propertyName, eventHandler, domNode, properties) { return modifiedEventHandler; };\r\n    };\r\n    /**\r\n     * Creates a [[Projector]] instance using the provided projectionOptions.\r\n     *\r\n     * For more information, see [[Projector]].\r\n     *\r\n     * @param projectorOptions   Options that influence how the DOM is rendered and updated.\r\n     */\r\n    var createProjector = function (projectorOptions) {\r\n        var projector;\r\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\r\n        var performanceLogger = projectionOptions.performanceLogger;\r\n        var renderCompleted = true;\r\n        var scheduled;\r\n        var stopped = false;\r\n        var projections = [];\r\n        var renderFunctions = []; // matches the projections array\r\n        var addProjection = function (\r\n        /* one of: dom.append, dom.insertBefore, dom.replace, dom.merge */\r\n        domFunction, \r\n        /* the parameter of the domFunction */\r\n        node, renderFunction) {\r\n            var projection;\r\n            var getProjection = function () { return projection; };\r\n            projectionOptions.eventHandlerInterceptor = createEventHandlerInterceptor(projector, getProjection, performanceLogger);\r\n            projection = domFunction(node, renderFunction(), projectionOptions);\r\n            projections.push(projection);\r\n            renderFunctions.push(renderFunction);\r\n        };\r\n        var doRender = function () {\r\n            scheduled = undefined;\r\n            if (!renderCompleted) {\r\n                return; // The last render threw an error, it should have been logged in the browser console.\r\n            }\r\n            renderCompleted = false;\r\n            performanceLogger('renderStart', undefined);\r\n            for (var i = 0; i < projections.length; i++) {\r\n                var updatedVnode = renderFunctions[i]();\r\n                performanceLogger('rendered', undefined);\r\n                projections[i].update(updatedVnode);\r\n                performanceLogger('patched', undefined);\r\n            }\r\n            performanceLogger('renderDone', undefined);\r\n            renderCompleted = true;\r\n        };\r\n        projector = {\r\n            renderNow: doRender,\r\n            scheduleRender: function () {\r\n                if (!scheduled && !stopped) {\r\n                    scheduled = requestAnimationFrame(doRender);\r\n                }\r\n            },\r\n            stop: function () {\r\n                if (scheduled) {\r\n                    cancelAnimationFrame(scheduled);\r\n                    scheduled = undefined;\r\n                }\r\n                stopped = true;\r\n            },\r\n            resume: function () {\r\n                stopped = false;\r\n                renderCompleted = true;\r\n                projector.scheduleRender();\r\n            },\r\n            append: function (parentNode, renderFunction) {\r\n                addProjection(dom.append, parentNode, renderFunction);\r\n            },\r\n            insertBefore: function (beforeNode, renderFunction) {\r\n                addProjection(dom.insertBefore, beforeNode, renderFunction);\r\n            },\r\n            merge: function (domNode, renderFunction) {\r\n                addProjection(dom.merge, domNode, renderFunction);\r\n            },\r\n            replace: function (domNode, renderFunction) {\r\n                addProjection(dom.replace, domNode, renderFunction);\r\n            },\r\n            detach: function (renderFunction) {\r\n                for (var i = 0; i < renderFunctions.length; i++) {\r\n                    if (renderFunctions[i] === renderFunction) {\r\n                        renderFunctions.splice(i, 1);\r\n                        return projections.splice(i, 1)[0];\r\n                    }\r\n                }\r\n                throw new Error('renderFunction was not found');\r\n            }\r\n        };\r\n        return projector;\r\n    };\n\n    /**\r\n     * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\r\n     * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\r\n     * For more information, see [[CalculationCache]].\r\n     *\r\n     * @param <Result> The type of the value that is cached.\r\n     */\r\n    var createCache = function () {\r\n        var cachedInputs;\r\n        var cachedOutcome;\r\n        return {\r\n            invalidate: function () {\r\n                cachedOutcome = undefined;\r\n                cachedInputs = undefined;\r\n            },\r\n            result: function (inputs, calculation) {\r\n                if (cachedInputs) {\r\n                    for (var i = 0; i < inputs.length; i++) {\r\n                        if (cachedInputs[i] !== inputs[i]) {\r\n                            cachedOutcome = undefined;\r\n                        }\r\n                    }\r\n                }\r\n                if (!cachedOutcome) {\r\n                    cachedOutcome = calculation();\r\n                    cachedInputs = inputs;\r\n                }\r\n                return cachedOutcome;\r\n            }\r\n        };\r\n    };\n\n    /**\r\n     * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\r\n     * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\r\n     *\r\n     * @param <Source>       The type of source items. A database-record for instance.\r\n     * @param <Target>       The type of target items. A [[MaquetteComponent]] for instance.\r\n     * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\r\n     * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\r\n     *                       to the `callback` argument in `Array.map(callback)`.\r\n     * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\r\n     */\r\n    var createMapping = function (getSourceKey, createResult, updateResult) {\r\n        var keys = [];\r\n        var results = [];\r\n        return {\r\n            results: results,\r\n            map: function (newSources) {\r\n                var newKeys = newSources.map(getSourceKey);\r\n                var oldTargets = results.slice();\r\n                var oldIndex = 0;\r\n                for (var i = 0; i < newSources.length; i++) {\r\n                    var source = newSources[i];\r\n                    var sourceKey = newKeys[i];\r\n                    if (sourceKey === keys[oldIndex]) {\r\n                        results[i] = oldTargets[oldIndex];\r\n                        updateResult(source, oldTargets[oldIndex], i);\r\n                        oldIndex++;\r\n                    }\r\n                    else {\r\n                        var found = false;\r\n                        for (var j = 1; j < keys.length + 1; j++) {\r\n                            var searchIndex = (oldIndex + j) % keys.length;\r\n                            if (keys[searchIndex] === sourceKey) {\r\n                                results[i] = oldTargets[searchIndex];\r\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\r\n                                oldIndex = searchIndex + 1;\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            results[i] = createResult(source, i);\r\n                        }\r\n                    }\r\n                }\r\n                results.length = newSources.length;\r\n                keys = newKeys;\r\n            }\r\n        };\r\n    };\n\n    exports.dom = dom;\n    exports.h = h;\n    exports.createProjector = createProjector;\n    exports.createCache = createCache;\n    exports.createMapping = createMapping;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:////home/mich/node_modules/maquette/dist/maquette.umd.js?");

/***/ }),

/***/ "./src/index.ls":
/*!**********************!*\
  !*** ./src/index.ls ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var maquette, h, projector, socket, model, render;\nmaquette = __webpack_require__(/*! maquette */ \"../../../../../../../node_modules/maquette/dist/maquette.umd.js\");\n__webpack_require__(/*! ./style.sass */ \"./src/style.sass\");\nh = maquette.h;\nprojector = maquette.createProjector();\nsocket = new WebSocket(\"ws://localhost:3000/\");\nmodel = {\n  state: \"login\",\n  login: \"\",\n  password: \"\",\n  menu: \": Page d'accueil\",\n  loginMenu: \": Page d'accueil\",\n  registerMenu: \": Enregistrement\",\n  gameMenu: \": Ecran de jeu\"\n};\nsocket.onmessage = function(event){\n  var message;\n  message = JSON.parse(event.data);\n  console.log(\"Message received => \" + message.data);\n  switch (message.type) {\n  case \"card\":\n    model.card = \"resources/\" + message.data + \".png\";\n    break;\n  case \"loginsuccess\":\n    model.state = \"index\";\n    model.menu = model.gameMenu;\n  }\n  return projector.scheduleRender();\n};\nrender = function(){\n  var x, y;\n  return h('div.section', [\n    h('div.gamename', {\n      key: \"gamename\"\n    }, [\"Bataille aéronavale\" + model.menu]), h('div.container', [(function(){\n      switch (model.state) {\n      case \"login\":\n        model.menu = model.loginMenu;\n        return h('div.form', {\n          key: \"login\"\n        }, [\n          h('input.hello', {\n            type: \"submit\",\n            value: \"Hello there!\",\n            onclick: function(e){\n              return alert(\"General Kenobi\");\n            }\n          }), h('input.input', {\n            type: \"text\",\n            oninput: function(e){\n              return model.login = e.target.value;\n            }\n          }), h('input.input', {\n            type: \"password\",\n            oninput: function(e){\n              return model.password = e.target.value;\n            }\n          }), h('input.button.is-fullwidth', {\n            type: \"submit\",\n            value: \"Sign in\",\n            onclick: function(e){\n              model.state = \"index\";\n              return model.menu = model.gameMenu;\n            }\n          }, [\"Send\"]), h('input.button.is-fullwidth', {\n            type: \"submit\",\n            value: \"Register\",\n            onclick: function(e){\n              model.state = \"register\";\n              model.menu = model.registerMenu;\n              return projector.scheduleRender();\n            }\n          }, [\"Register\"])\n        ]);\n      case \"register\":\n        return h('div.form', {\n          key: \"register\"\n        }, [\n          h('input.input', {\n            type: \"text\",\n            oninput: function(e){\n              return model.login = e.target.value;\n            }\n          }), h('input.input', {\n            type: \"password\",\n            oninput: function(e){\n              return model.password = e.target.value;\n            }\n          }), h('input.button', {\n            type: \"submit\",\n            value: \"Sign up\",\n            onclick: function(e){\n              return socket.send(JSON.stringify({\n                type: \"register\",\n                login: model.login,\n                password: model.password\n              }));\n            }\n          }, [\"Send\"]), h('input.button', {\n            value: \"Go back\",\n            onclick: function(e){\n              model.state = 'login';\n              model.menu = model.loginMenu;\n              return projector.scheduleRender();\n            }\n          })\n        ]);\n      case \"index\":\n        model.menu = \": Ecran de jeu\";\n        return h('div.container', {\n          key: \"maindiv\"\n        }, [\n          h('div.grid1', [(function(){\n            var i$, ref$, len$, lresult$, j$, ref1$, len1$, results$ = [];\n            for (i$ = 0, len$ = (ref$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).length; i$ < len$; ++i$) {\n              x = ref$[i$];\n              lresult$ = [];\n              for (j$ = 0, len1$ = (ref1$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).length; j$ < len1$; ++j$) {\n                y = ref1$[j$];\n                lresult$.push(h(\"div.tile\", {\n                  key: '1:' + x + ':' + y,\n                  style: \"display: inline-block;\\nposition: absolute;\\nleft: \" + 32 * y + \"px;\\ntop: \" + 32 * x + \"px;\\nwidth: 32px;\\nheight: 32px;\"\n                }));\n              }\n              results$.push(lresult$);\n            }\n            return results$;\n          }())]), h('div.grid2', [(function(){\n            var i$, ref$, len$, lresult$, j$, ref1$, len1$, results$ = [];\n            for (i$ = 0, len$ = (ref$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).length; i$ < len$; ++i$) {\n              x = ref$[i$];\n              lresult$ = [];\n              for (j$ = 0, len1$ = (ref1$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).length; j$ < len1$; ++j$) {\n                y = ref1$[j$];\n                lresult$.push(h(\"div.tile\", {\n                  key: '2:' + x + ':' + y,\n                  style: \"display: inline-block;\\nposition: absolute;\\nleft: \" + 32 * y + \"px;\\ntop: \" + 32 * x + \"px;\\nwidth: 32px;\\nheight: 32px;\"\n                }));\n              }\n              results$.push(lresult$);\n            }\n            return results$;\n          }())]), h('input.button', {\n            value: 'Disconnect',\n            onclick: function(e){\n              model.login = \"\";\n              model.password = \"\";\n              model.state = \"login\";\n              model.menu = model.loginMenu;\n              return projector.scheduleRender();\n            }\n          })\n        ]);\n      }\n    }())])\n  ]);\n};\ndocument.addEventListener('DOMContentLoaded', function(){\n  return projector.append(document.body, render);\n});\n//# sourceMappingURL=index.ls.map\n\n\n//# sourceURL=webpack:///./src/index.ls?");

/***/ }),

/***/ "./src/style.sass":
/*!************************!*\
  !*** ./src/style.sass ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style.sass?");

/***/ })

/******/ });